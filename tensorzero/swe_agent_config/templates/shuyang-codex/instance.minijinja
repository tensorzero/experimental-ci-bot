{{task}}

## CI Failure Information

The CI failure details are available in the file `ci_failure_context.md` in the current directory.
Read this file first to understand what failed and why.

## Recommended Workflow

Work step-by-step to ensure you can iterate on your changes and catch any problems:

1. **Read the CI failure context** - `cat ci_failure_context.md`
2. **Analyze the codebase** - Find and read relevant files mentioned in the failure
3. **Understand the root cause** - Identify why the tests/checks are failing
4. **Restate the repro** - Identify the exact failing job/test and the command to reproduce
5. **Create a reproduction script** (if applicable) - Verify you can reproduce the failure locally
6. **Make targeted fixes** - Edit the smallest relevant area first
7. **Run validation** - Follow AGENTS.md for stack-specific commands (Rust: `cargo fmt`, `cargo clippy --all-targets --all-features -- -D warnings`, `cargo check`, `cargo test-unit-fast`; UI: from `ui/` run `pnpm run format`, `pnpm run lint`, `pnpm run typecheck`; Rust→TS bindings: `pnpm build-bindings` then `pnpm -r build` and `pnpm -r typecheck`; Python deps: keep `uv.lock` and `requirements.txt` in sync via `uv lock` and `uv export`). Choose only the commands that match the code you touched.
8. **Iterate if needed** - If validation fails, debug and fix until all checks pass
9. **Decide on delivery method** - Choose between inline suggestions or PR
10. **Submit your work** - Use the completion command with your decision

## Important Rules

1. Every response must contain exactly one action in triple backticks
2. Directory or environment variable changes are not persistent - every action runs in a new subshell
3. You can prefix commands with environment variables or directory changes: `cd /path && command`
4. You can write/load environment variables from files if needed
5. Cannot modify GitHub Actions workflows (only repository code)
6. If a command needs more time, add '# timeout: <seconds>' on the first line (max {{max_timeout}} seconds).
7. Each command runs in a fresh subshell (no persistent shell state); chain with `&&` when you need sequential work.
8. Keep outputs concise; prefer `rg`, `sed`, `head`, `tail`, or targeted tests over verbose logs.

<system_information>
{{system}} {{release}} {{version}} {{machine}}
</system_information>

## Validation Commands Reference

Use the stack-specific commands that match your edits:

### Rust (tensorzero-core, gateway, etc.)
```bash
cargo fmt
cargo clippy --all-targets --all-features -- -D warnings
cargo check
cargo test-unit-fast
```

### Docker Compose / examples
```bash
./ci/check-all-docker-compose.sh
```

### Coordinated edits / version checks
```bash
./ci/check-version-consistency.sh
python3 ci/check_coordinated_edits.py
```

### Rust → TypeScript bindings
```bash
cd internal/tensorzero-node && pnpm build-bindings
pnpm -r build
pnpm -r typecheck
```

### UI
```bash
cd ui && pnpm run format && pnpm run lint && pnpm run typecheck
```

### Python deps
```bash
uv lock --project="pyproject.toml"
uv export --project="pyproject.toml" --output-file="requirements.txt"
```

## Useful Command Examples

### Create a new file:
```bash
cat <<'EOF' > newfile.py
import numpy as np
hello = "world"
print(hello)
EOF
```

TODO: add an edit command

### View file content:
```bash
# View specific lines with numbers
nl -ba filename.py | sed -n '10,20p'

# View entire file
cat filename.py
```

## Example Session

<example_response>
THOUGHT: I need to first read the CI failure context to understand what went wrong in the pull request.

```bash
cat ci_failure_context.md
```
</example_response>

## With max_timeout
```bash
# timeout: 300
uv run expensive_script.py
```

Now begin your work!
Do not commit to git or anything, just signal completion when you are happy with the state of the project.
