{{task}}

## CI Failure Information
`cat ci_failure_context.md` to see what failed.

## Workflow (mini-swe-agent, fresh subshell per command)
1. Read `ci_failure_context.md`.
2. Identify failing job/test and restate the repro command.
3. Inspect relevant files; use `rg` to find all call sites if changing signatures.
4. Make the smallest change to fix the repro.
5. Validate using only the commands that match your edits:
   - Rust: `cargo fmt` → `cargo clippy --all-targets --all-features -- -D warnings` → `cargo check` → `cargo test-unit-fast`.
   - Rust→TS bindings: `cd internal/tensorzero-node && pnpm build-bindings`; `pnpm -r build`; `pnpm -r typecheck`.
   - UI: `cd ui && pnpm run format && pnpm run lint && pnpm run typecheck`.
   - Docker/examples: `./ci/check-all-docker-compose.sh`.
   - Version/coordinated edits: `./ci/check-version-consistency.sh`; `python3 ci/check_coordinated_edits.py`.
   - Python deps: `uv lock --project="pyproject.toml"`; `uv export --project="pyproject.toml" --output-file="requirements.txt"`.
   - Buildkite-triggered jobs aren’t reproducible; rely on logs and run the closest local checks.
6. If validation fails, fix and rerun the targeted checks.
7. Finish with the required completion command only.

## Rules
- One action per reply, in a bash block; THOUGHT + code block only.
- Fresh subshell each time; chain with `&&` for sequential work.
- Default timeout 30s; use `# timeout: <seconds>` (max {{max_timeout}}) only if needed.
- Keep output concise—prefer `rg`, `sed`, `head`, `tail`, targeted tests/logs.
- No workflow file edits; no real network/secrets. Use dummy envs for docker-compose (e.g., `OPENAI_API_KEY=dummy`).

<system_information>
{{system}} {{release}} {{version}} {{machine}}
</system_information>

## Useful Commands
- View file snippets: `nl -ba file | sed -n '10,30p'`
- Search: `rg pattern path`
- Create file: `cat <<'EOF' > file\n...\nEOF`
- Edit in-place example: `apply_patch` is unavailable here; instead use `perl -0pi -e 's/old/new/' file` or `python - <<'PY'\nfrom pathlib import Path\np=Path(\"file\"); p.write_text(p.read_text().replace(\"old\",\"new\"))\nPY`

## Useful Command Examples

### Create a new file:
```bash
cat <<'EOF' > newfile.py
import numpy as np
hello = "world"
print(hello)
EOF
```

### Edit a file in place:
```bash
python - <<'PY'
from pathlib import Path
p = Path("filename.py")
p.write_text(p.read_text().replace("old_text", "new_text"))
PY
```

### View file content:
```bash
# View specific lines with numbers
nl -ba filename.py | sed -n '10,20p'

# View entire file
cat filename.py
```

## Example Session

<example_response>
THOUGHT: I need to first read the CI failure context to understand what went wrong in the pull request.

```bash
cat ci_failure_context.md
```
</example_response>

## With max_timeout
```bash
# timeout: 300
uv run expensive_script.py
```

Now begin your work!
Do not commit to git or anything, just signal completion when you are happy with the state of the project.
